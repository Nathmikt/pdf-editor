<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/x-icon" href="pedefeul_logo.png">
  <title>Editor pdf gratis - pedefeul.ro</title>
  <!-- Manually bump css version before each commit/deploy -->
  <link rel="stylesheet" href="style.css?v=1.3.0">
  <!-- pdf.js (viewer/renderer) -->
  <script src="https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.min.js"></script>
  <!-- pdf-lib (writer) -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>

<body>
  <header class="app-header">
    <div class="header-top">
      <img src="pedefeul_logo2.png" alt="Pedefeul logo" class="logo">
      <div class="titles">
        <div id="eyebrow"> PEDEFEUL.ro</div>
        <div class="control-bar">
          <label>Text: <input id="text" type="text" placeholder="..."></label>
          <label>Mărime: <input id="size" type="number" value="14" min="6" max="72"></label>
          <label>Culoare: <input id="color" type="color"></label>
          <label>Font:
            <select id="font">
              <option value="helvetica">Helvetica</option>
              <option value="times">Times</option>
              <option value="courier">Courier</option>
            </select>
          </label>
          <button id="place" disabled>Plasează</button>
          <button id="signature" disabled>Semnătură</button>
          <button id="save" disabled>Salvează</button>
          <button id="reset" disabled>Resetează</button>
        </div>
      </div>
    </div>

  </header>

  <main class="app-body">
    <section class="upload-section">
      <h1>Editor gratis de fișiere .pdf</h1>
      <p class="upload-instructions">Încarcă fișierul tău pentru a putea adăuga text.</p>
      <label class="upload-button" for="file">Încarcă fișier</label>
      <input id="file" type="file" accept="application/pdf">
    </section>

    <div id="pages"></div>
  </main>

  <div id="signature-modal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Desenează semnătura</h2>
        <button type="button" id="signature-cancel" class="icon-btn" aria-label="Închide">&#10005;</button>
      </div>
      <p class="modal-subtitle">Desenează cu mouse-ul sau cu degetul, apoi apasă Salvează pentru a o așeza în pagină.
      </p>
      <div class="signature-canvas-wrapper">
        <canvas id="signature-canvas" width="520" height="200"></canvas>
      </div>
      <div class="modal-actions">
        <button type="button" id="signature-clear">Șterge</button>
        <button type="button" id="signature-save">Salvează</button>
      </div>
    </div>
  </div>

  <!-- MUST be type="module" to use JS imports -->
  <script type="module">
    import * as pdfjsLib from "https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.mjs";

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.worker.mjs";

    // Make globally accessible if needed
    window.pdfjsLib = pdfjsLib;

    let originalU8 = null;
    let originalBytes = null;          // ArrayBuffer of the uploaded PDF
    let docMeta = [];                  // per-page: {scale, width, height}
    let marks = [];                    // per-page array of placed marks (text/signature)
    let selectedMark = null;           // { el, data, pageIndex }
    let markIdCounter = 0;
    let pendingPlacement = null;       // { type, ... }
    const fileInput = document.getElementById('file');
    const textInput = document.getElementById('text');
    const sizeInput = document.getElementById('size');
    const colorInput = document.getElementById('color');
    const fontSelect = document.getElementById('font');
    const placeBtn = document.getElementById('place');
    const signatureBtn = document.getElementById('signature');
    const pagesEl = document.getElementById('pages');
    const saveBtn = document.getElementById('save');
    const uploadSection = document.querySelector('.upload-section');
    const resetBtn = document.getElementById('reset');
    const signatureModal = document.getElementById('signature-modal');
    const signatureCanvas = document.getElementById('signature-canvas');
    const signatureClearBtn = document.getElementById('signature-clear');
    const signatureSaveBtn = document.getElementById('signature-save');
    const signatureCancelBtn = document.getElementById('signature-cancel');
    const signatureCtx = signatureCanvas.getContext('2d');
    let signatureHasInk = false;
    let signatureCanvasSize = { width: 520, height: 200 };

    const fontMap = {
      helvetica: {
        pdf: () => PDFLib.StandardFonts.Helvetica,
        css: 'Helvetica, Arial, sans-serif'
      },
      times: {
        pdf: () => PDFLib.StandardFonts.TimesRoman,
        css: '\'Times New Roman\', Times, serif'
      },
      courier: {
        pdf: () => PDFLib.StandardFonts.Courier,
        css: '\'Courier New\', Courier, monospace'
      }
    };

    function updatePlaceButtonState() {
      const hasText = !!textInput.value.trim();
      const hasPdf = !!originalBytes;
      placeBtn.disabled = !hasPdf || !hasText || !!pendingPlacement;
      updateSignatureButtonState();
    }

    function updateSignatureButtonState() {
      signatureBtn.disabled = !originalBytes || !!pendingPlacement;
    }

    function updateSignatureActionState() {
      signatureSaveBtn.disabled = !signatureHasInk;
      signatureClearBtn.disabled = !signatureHasInk;
    }

    function resizeSignatureCanvas() {
      const rect = signatureCanvas.getBoundingClientRect();
      const width = rect.width || signatureCanvasSize.width;
      const height = rect.height || signatureCanvasSize.height;
      signatureCanvasSize = { width, height };
      signatureCanvas.width = width;
      signatureCanvas.height = height;
      signatureCtx.lineWidth = 2;
      signatureCtx.lineCap = 'round';
      signatureCtx.lineJoin = 'round';
      signatureCtx.strokeStyle = '#000000';
      signatureCtx.clearRect(0, 0, width, height);
      signatureHasInk = false;
      updateSignatureActionState();
    }

    function clearSignatureCanvas() {
      signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      signatureHasInk = false;
      updateSignatureActionState();
    }

    function openSignatureModal() {
      signatureModal.classList.remove('hidden');
      requestAnimationFrame(resizeSignatureCanvas);
    }

    function closeSignatureModal() {
      signatureModal.classList.add('hidden');
    }

    function getSignaturePoint(clientX, clientY) {
      const rect = signatureCanvas.getBoundingClientRect();
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    let drawingSignature = false;

    function startSignatureStroke(x, y) {
      drawingSignature = true;
      signatureCtx.beginPath();
      signatureCtx.moveTo(x, y);
      signatureHasInk = true;
      updateSignatureActionState();
    }

    function continueSignatureStroke(x, y) {
      if (!drawingSignature) return;
      signatureCtx.lineTo(x, y);
      signatureCtx.stroke();
    }

    function endSignatureStroke() {
      drawingSignature = false;
    }

    function clearSelection() {
      if (!selectedMark) return;
      selectedMark.el.classList.remove('selected');
      selectedMark = null;
    }

    function setSelectedMarkSize(sizeValue) {
      if (!selectedMark || selectedMark.data.type !== 'text') return;
      const numeric = Number(sizeValue);
      if (!Number.isFinite(numeric)) return;
      const min = Number(sizeInput.min) || 0;
      const max = Number(sizeInput.max) || numeric;
      const clamped = Math.min(Math.max(numeric, min), max);
      selectedMark.data.size = clamped;
      selectedMark.el.style.fontSize = `${clamped}px`;
      sizeInput.value = clamped;
    }

    function setSelectedMarkFont(fontKey) {
      if (!selectedMark || selectedMark.data.type !== 'text') return;
      const key = fontMap[fontKey] ? fontKey : 'helvetica';
      selectedMark.data.font = key;
      selectedMark.el.style.fontFamily = fontMap[key].css;
      fontSelect.value = key;
    }

    function setSelectedMarkColor(colorValue) {
      if (!selectedMark || selectedMark.data.type !== 'text') return;
      const fallback = '#000000';
      const val = typeof colorValue === 'string' && colorValue.trim() ? colorValue : fallback;
      selectedMark.data.color = val;
      selectedMark.el.style.color = val;
      colorInput.value = val;
    }

    function selectMark(markEl, markData, pageIndex) {
      if (selectedMark && selectedMark.el === markEl) return;
      clearSelection();
      selectedMark = { el: markEl, data: markData, pageIndex };
      markEl.classList.add('selected');
      if (markData.type === 'text') {
        sizeInput.value = markData.size;
        fontSelect.value = fontMap[markData.font] ? markData.font : 'helvetica';
        colorInput.value = markData.color || '#000000';
      }
    }

    function deleteMark(pageIndex, markData, markEl) {
      marks[pageIndex] = marks[pageIndex].filter(m => m !== markData);
      if (markEl.parentNode) {
        markEl.parentNode.removeChild(markEl);
      }
      if (selectedMark && selectedMark.el === markEl) {
        selectedMark = null;
      }
      const hasMarks = marks.some(arr => arr.length > 0);
      saveBtn.disabled = !hasMarks;
    }

    function editMarkText(markEl, markData) {
      if (markData.type !== 'text') return;
      const textSpan = markEl.querySelector('.mark-text');
      if (!textSpan || markEl.classList.contains('editing')) return;

      const previousText = markData.text;
      markEl.classList.add('editing');
      textSpan.contentEditable = 'true';
      textSpan.focus();

      // Select all text for quick editing
      const range = document.createRange();
      range.selectNodeContents(textSpan);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);

      function finish(save) {
        textSpan.contentEditable = 'false';
        markEl.classList.remove('editing');
        textSpan.removeEventListener('blur', onBlur);
        textSpan.removeEventListener('keydown', onKey);
        if (save) {
          markData.text = textSpan.textContent;
        } else {
          textSpan.textContent = previousText;
        }
      }

      function onBlur() {
        finish(true);
      }

      function onKey(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          textSpan.blur();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          finish(false);
          textSpan.blur();
        }
      }

      textSpan.addEventListener('blur', onBlur);
      textSpan.addEventListener('keydown', onKey);
    }

    function attachMarkDragging(markEl, markData, overlay, pageIndex) {
      function handleStart(startX, startY) {
        if (markEl.classList.contains('editing')) return;
        const rect = overlay.getBoundingClientRect();
        // Calculate offset as a percentage of the dimension
        // offsetX = (mouseVal - rectEdge) - (permPos% * rectDim)
        // actually easier to track offset in pixels for the move calculation
        const currentLeftPx = markData.x * rect.width;
        const currentTopPx = markData.y * rect.height;

        const offsetX = (startX - rect.left) - currentLeftPx;
        const offsetY = (startY - rect.top) - currentTopPx;

        function move(currX, currY) {
          let newLeftPx = currX - rect.left - offsetX;
          let newTopPx = currY - rect.top - offsetY;

          // Clamp to boundaries
          newLeftPx = Math.max(0, Math.min(newLeftPx, rect.width - markEl.offsetWidth));
          newTopPx = Math.max(0, Math.min(newTopPx, rect.height - markEl.offsetHeight));

          const pctX = newLeftPx / rect.width;
          const pctY = newTopPx / rect.height;

          markData.x = pctX;
          markData.y = pctY;
          markEl.style.left = (pctX * 100) + '%';
          markEl.style.top = (pctY * 100) + '%';
        }

        return move;
      }

      function onMouseDown(e) {
        const moveFn = handleStart(e.clientX, e.clientY);
        if (!moveFn) return;

        e.preventDefault();
        e.stopPropagation();

        function onMouseMove(moveEv) {
          moveFn(moveEv.clientX, moveEv.clientY);
        }

        function onMouseUp(upEv) {
          upEv.stopPropagation();
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      }

      function onTouchStart(e) {
        if (e.touches.length !== 1) return;
        const touch = e.touches[0];
        const moveFn = handleStart(touch.clientX, touch.clientY);
        if (!moveFn) return;

        e.stopPropagation();
        // Don't preventDefault here immediately, or we might block scrolling? 
        // Actually, if we are dragging a mark, we DO want to block scrolling.
        // But if the user taps to select, we don't want to block everything.
        // We'll preventDefault in move to be safe, or start. 
        // For dragging, usually preventDefault on start is best to stop browser behavior.
        e.preventDefault();

        function onTouchMove(moveEv) {
          moveEv.preventDefault(); // Stop scrolling
          const t = moveEv.touches[0];
          moveFn(t.clientX, t.clientY);
        }

        function onTouchEnd(endEv) {
          // Cleanup
          document.removeEventListener('touchmove', onTouchMove);
          document.removeEventListener('touchend', onTouchEnd);
        }

        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchend', onTouchEnd);
      }

      markEl.addEventListener('mousedown', onMouseDown);
      markEl.addEventListener('touchstart', onTouchStart, { passive: false });

      markEl.addEventListener('click', (ev) => {
        ev.stopPropagation();
        selectMark(markEl, markData, pageIndex);
      });
      // Add touchend for selection if click is unreliable/delayed? 
      // Ideally click is fine. But let's leave it standard for now.

      if (markData.type === 'text') {
        markEl.addEventListener('dblclick', (ev) => {
          ev.stopPropagation();
          selectMark(markEl, markData, pageIndex);
          editMarkText(markEl, markData);
        });
      }
    }

    function attachMarkResizing(markEl, markData, overlay, handle) {
      function handleStart(startX, startY) {
        const rect = overlay.getBoundingClientRect();
        const startWidthPct = markData.w;
        const startHeightPct = markData.h;
        const startXPos = startX;
        const aspectRatio = startWidthPct / startHeightPct;

        function move(currX, currY) {
          // Calculate delta in pixels, then convert to percentage
          const deltaX = currX - startXPos;
          const deltaXPct = deltaX / rect.width;

          let newWidthPct = Math.max(0.05, startWidthPct + deltaXPct);
          let newHeightPct = newWidthPct / aspectRatio;

          markData.w = newWidthPct;
          markData.h = newHeightPct;

          markEl.style.width = (newWidthPct * 100) + '%';
          // auto height for element, but we track h for PDF
        }

        return move;
      }

      function onMouseDown(e) {
        e.stopPropagation();
        e.preventDefault();
        const moveFn = handleStart(e.clientX, e.clientY);

        function onMouseMove(moveEv) {
          moveFn(moveEv.clientX, moveEv.clientY);
        }

        function onMouseUp(upEv) {
          upEv.stopPropagation();
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      }

      function onTouchStart(e) {
        if (e.touches.length !== 1) return;
        e.stopPropagation();
        e.preventDefault();

        const t = e.touches[0];
        const moveFn = handleStart(t.clientX, t.clientY);

        function onTouchMove(moveEv) {
          moveEv.preventDefault();
          const img = moveEv.touches[0];
          moveFn(img.clientX, img.clientY);
        }

        function onTouchEnd(endEv) {
          document.removeEventListener('touchmove', onTouchMove);
          document.removeEventListener('touchend', onTouchEnd);
        }

        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchend', onTouchEnd);
      }

      handle.addEventListener('mousedown', onMouseDown);
      handle.addEventListener('touchstart', onTouchStart, { passive: false });
    }

    function placeMark(pageIndex, overlay, xPx, yPx, placement) {
      if (!placement) return;

      const rect = overlay.getBoundingClientRect();
      const xPct = xPx / rect.width;
      const yPct = yPx / rect.height;

      if (placement.type === 'signature') {
        let widthPct, heightPct;

        if (placement.isRelative) {
          // New logic: simpler, consistent size
          widthPct = placement.targetPct || 0.25;
          heightPct = widthPct / placement.aspectRatio;
        } else {
          // Fallback or legacy logic
          widthPct = placement.width / rect.width;
          heightPct = placement.height / rect.height;
        }

        const markData = {
          id: markIdCounter++,
          type: 'signature',
          x: xPct,
          y: yPct,
          src: placement.src,
          w: widthPct,
          h: heightPct
        };
        marks[pageIndex].push(markData);

        const m = document.createElement('div');
        m.className = 'mark signature-mark';
        m.style.left = (xPct * 100) + '%';
        m.style.top = (yPct * 100) + '%';
        m.style.width = (widthPct * 100) + '%';
        // We use auto height for the DOM element to keep aspect ratio, 
        // as the img will fill width.
        m.style.height = 'auto';

        const img = document.createElement('img');
        img.src = placement.src;
        img.alt = 'Semnătură';
        img.style.width = '100%';
        img.style.height = 'auto';
        m.appendChild(img);

        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        m.appendChild(handle);

        const delBtn = document.createElement('button');
        delBtn.type = 'button';
        delBtn.className = 'delete-btn';
        delBtn.textContent = 'x';
        delBtn.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          deleteMark(pageIndex, markData, m);
        });

        attachMarkDragging(m, markData, overlay, pageIndex);
        attachMarkResizing(m, markData, overlay, handle);
        m.appendChild(delBtn);
        overlay.appendChild(m);
        saveBtn.disabled = false;
        selectMark(m, markData, pageIndex);
        return;
      }

      const fontInfo = fontMap[placement.font] || fontMap.helvetica;
      const markData = {
        id: markIdCounter++,
        type: 'text',
        x: xPct,
        y: yPct,
        text: placement.text,
        size: placement.size,
        font: placement.font,
        color: placement.color
      };
      marks[pageIndex].push(markData);

      const m = document.createElement('div');
      m.className = 'mark';
      m.style.fontSize = placement.size + 'px'; // Font size remains absolute px for UI availability
      m.style.left = (xPct * 100) + '%';
      m.style.top = (yPct * 100) + '%';
      m.style.color = placement.color;
      m.style.fontFamily = fontInfo.css;

      const textSpan = document.createElement('span');
      textSpan.className = 'mark-text';
      textSpan.textContent = placement.text;
      m.appendChild(textSpan);

      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.className = 'delete-btn';
      delBtn.textContent = 'x';
      delBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        deleteMark(pageIndex, markData, m);
      });

      attachMarkDragging(m, markData, overlay, pageIndex);
      m.appendChild(delBtn);
      overlay.appendChild(m);
      saveBtn.disabled = false;
      selectMark(m, markData, pageIndex);
    }

    placeBtn.addEventListener('click', () => {
      const text = textInput.value.trim();
      if (!text) return;
      const size = +sizeInput.value || 14;
      const font = fontSelect.value;
      const color = colorInput.value || '#000000';
      pendingPlacement = { type: 'text', text, size, font, color };
      updatePlaceButtonState();
    });

    textInput.addEventListener('input', updatePlaceButtonState);
    sizeInput.addEventListener('input', () => {
      if (!selectedMark) return;
      setSelectedMarkSize(sizeInput.value);
    });
    fontSelect.addEventListener('change', () => {
      if (!selectedMark) return;
      setSelectedMarkFont(fontSelect.value);
    });
    colorInput.addEventListener('input', () => {
      if (!selectedMark) return;
      setSelectedMarkColor(colorInput.value);
    });

    signatureBtn.addEventListener('click', () => {
      pendingPlacement = null;
      openSignatureModal();
      updatePlaceButtonState();
    });

    signatureCancelBtn.addEventListener('click', () => {
      closeSignatureModal();
      clearSignatureCanvas();
    });

    signatureClearBtn.addEventListener('click', () => {
      clearSignatureCanvas();
    });

    signatureSaveBtn.addEventListener('click', () => {
      if (!signatureHasInk) return;

      // Default to 25% of the page width (better for mobile uniformity)
      const baseWidth = signatureCanvasSize.width || signatureCanvas.width || 520;
      const baseHeight = signatureCanvasSize.height || signatureCanvas.height || 200;

      // Instead of fixed pixels, we define a target percentage width
      // But we need the ASPECT RATIO of the signature
      const aspectRatio = baseWidth / baseHeight;

      // We'll calculate the actual width/height percentages in placeMark
      // Here we just pass the src and aspect info, OR we simulate a width.
      // Actually, placeMark expects 'placement.width' to be a pixel value in the current logic.
      // But we modified placeMark logic? No, placeMark takes `placement.width` and div by rect.width.

      // Let's pass a "pseudo-pixel" width that forces the percentage calculation 
      // in placeMark to result in exactly 25%?
      // No, let's just use the current viewer width reference if possible. 
      // But we aren't in a page context here.

      // Better: Store aspect ratio in pendingPlacement
      pendingPlacement = {
        type: 'signature',
        src: signatureCanvas.toDataURL('image/png'),
        isRelative: true, // Signal to use relative sizing
        targetPct: 0.25,  // 25% width
        aspectRatio: aspectRatio
      };

      closeSignatureModal();
      clearSelection();
      updatePlaceButtonState();
    });

    signatureCanvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const { x, y } = getSignaturePoint(e.clientX, e.clientY);
      startSignatureStroke(x, y);
    });

    signatureCanvas.addEventListener('mousemove', (e) => {
      if (!drawingSignature) return;
      e.preventDefault();
      const { x, y } = getSignaturePoint(e.clientX, e.clientY);
      continueSignatureStroke(x, y);
    });

    ['mouseup', 'mouseleave'].forEach(evt => {
      signatureCanvas.addEventListener(evt, () => {
        if (drawingSignature) endSignatureStroke();
      });
    });

    signatureCanvas.addEventListener('touchstart', (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      const { x, y } = getSignaturePoint(t.clientX, t.clientY);
      e.preventDefault();
      startSignatureStroke(x, y);
    }, { passive: false });

    signatureCanvas.addEventListener('touchmove', (e) => {
      if (!drawingSignature || e.touches.length !== 1) return;
      const t = e.touches[0];
      const { x, y } = getSignaturePoint(t.clientX, t.clientY);
      e.preventDefault();
      continueSignatureStroke(x, y);
    }, { passive: false });

    ['touchend', 'touchcancel'].forEach(evt => {
      signatureCanvas.addEventListener(evt, () => endSignatureStroke());
    });
    updateSignatureActionState();
    updatePlaceButtonState();

    function enterEditMode() {
      uploadSection.classList.add('hidden');
      resetBtn.disabled = false;
    }

    function resetApp() {
      clearSelection();
      pagesEl.innerHTML = '';
      originalU8 = null;
      originalBytes = null;
      docMeta = [];
      marks = [];
      markIdCounter = 0;
      pendingPlacement = null;
      textInput.value = '';
      sizeInput.value = '14';
      fontSelect.value = 'helvetica';
      saveBtn.disabled = true;
      closeSignatureModal();
      clearSignatureCanvas();
      signatureHasInk = false;
      signatureCanvasSize = { width: 520, height: 200 };
      updateSignatureActionState();
      updatePlaceButtonState();
      fileInput.value = '';
      uploadSection.classList.remove('hidden');
      resetBtn.disabled = true;
    }

    // Render uploaded PDF
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const buf = await file.arrayBuffer();
      const u8 = new Uint8Array(buf);

      // Reset state for new document
      clearSelection();
      pendingPlacement = null;
      markIdCounter = 0;
      saveBtn.disabled = true;
      updatePlaceButtonState();

      // Keep a private copy for pdf-lib (never hand this to pdf.js)
      originalU8 = u8.slice();
      originalBytes = originalU8.buffer;
      updatePlaceButtonState();

      // Hand a separate clone to pdf.js (it can detach this one)
      const renderU8 = u8.slice();
      const pdf = await pdfjsLib.getDocument({ data: renderU8 }).promise;

      pagesEl.innerHTML = '';
      docMeta = []; marks = [];

      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const scale = 1.25; // render scale (UI only)
        const viewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');

        await page.render({ canvasContext: ctx, viewport }).promise;

        // container and overlay for marks
        const wrapper = document.createElement('div');
        wrapper.className = 'page';
        wrapper.appendChild(canvas);

        const overlay = document.createElement('div');
        overlay.className = 'overlay';
        overlay.style.width = canvas.width + 'px';
        overlay.style.height = canvas.height + 'px';
        wrapper.appendChild(overlay);

        // click to place text
        // click to place text
        const pageIndex = p - 1;

        function handlePlacement(clientX, clientY) {
          if (!originalBytes) return;
          if (!pendingPlacement) return;

          const r = overlay.getBoundingClientRect();
          const x = clientX - r.left;
          const y = clientY - r.top;

          const placement = pendingPlacement;
          placeMark(pageIndex, overlay, x, y, placement);
          if (placement.type === 'text') {
            textInput.value = '';
          }
          pendingPlacement = null;
          updatePlaceButtonState();
        }

        wrapper.addEventListener('click', (ev) => {
          if (ev.target.classList.contains('mark') || ev.target.closest('.mark')) return;
          handlePlacement(ev.clientX, ev.clientY);
        });

        // Add touchend for placing on mobile
        wrapper.addEventListener('touchend', (ev) => {
          if (!pendingPlacement) return;
          if (ev.changedTouches.length !== 1) return;
          const t = ev.changedTouches[0];

          // Avoid hitting a mark
          const target = document.elementFromPoint(t.clientX, t.clientY);
          if (target && (target.classList.contains('mark') || target.closest('.mark'))) return;

          ev.preventDefault();
          handlePlacement(t.clientX, t.clientY);
        });

        pagesEl.appendChild(wrapper);
        docMeta.push({ scale, width: viewport.width, height: viewport.height, pdfWidth: page.view[2], pdfHeight: page.view[3] });
        marks.push([]);
      }

      enterEditMode();
    });

    resetBtn.addEventListener('click', resetApp);

    // Save: write overlays into the PDF using pdf-lib
    saveBtn.addEventListener('click', async () => {
      if (!originalBytes) return;

      const pdfDoc = await PDFLib.PDFDocument.load(originalU8, { updateMetadata: false });
      const fontCache = {};
      const imageCache = {};

      function hexToRgb(hex) {
        if (typeof hex !== 'string') return { r: 0, g: 0, b: 0 };
        const cleaned = hex.replace('#', '').trim();
        if (cleaned.length === 3) {
          const r = parseInt(cleaned[0] + cleaned[0], 16);
          const g = parseInt(cleaned[1] + cleaned[1], 16);
          const b = parseInt(cleaned[2] + cleaned[2], 16);
          return { r, g, b };
        }
        if (cleaned.length === 6) {
          const r = parseInt(cleaned.slice(0, 2), 16);
          const g = parseInt(cleaned.slice(2, 4), 16);
          const b = parseInt(cleaned.slice(4, 6), 16);
          if ([r, g, b].some(v => Number.isNaN(v))) return { r: 0, g: 0, b: 0 };
          return { r, g, b };
        }
        return { r: 0, g: 0, b: 0 };
      }

      async function getEmbeddedFont(key) {
        const fontKey = key && fontMap[key] ? key : 'helvetica';
        if (fontCache[fontKey]) return fontCache[fontKey];
        const fontName = fontMap[fontKey].pdf();
        const embedded = await pdfDoc.embedFont(fontName);
        fontCache[fontKey] = embedded;
        return embedded;
      }

      async function getEmbeddedImage(src) {
        if (imageCache[src]) return imageCache[src];
        const img = await pdfDoc.embedPng(src);
        imageCache[src] = img;
        return img;
      }

      for (let i = 0; i < pdfDoc.getPageCount(); i++) {
        const page = pdfDoc.getPage(i);
        const pageSize = page.getSize(); // { width, height } in PDF points
        const { scale } = docMeta[i];

        // Convert screen (canvas) coords to PDF user space:
        // mark.x is 0..1 percentage
        for (const m of marks[i]) {
          if (m.type === 'signature') {
            const img = await getEmbeddedImage(m.src);
            // w is percentage of width
            const pdfW = m.w * pageSize.width;
            // h is percentage of height ?? No, h was percentage of canvas height.
            // pageSize.height might be different aspect ratio if canvas layout was different?
            // Usually pdf.js canvas matches aspect ratio.
            const pdfH = m.h * pageSize.height;

            const pdfX = m.x * pageSize.width;
            // PDF Y is from bottom. m.y is from top (0..1).
            const pdfY = pageSize.height - (m.y * pageSize.height) - pdfH;

            page.drawImage(img, { x: pdfX, y: pdfY, width: pdfW, height: pdfH });
            continue;
          }

          const pdfSize = m.size / scale;
          const font = await getEmbeddedFont(m.font);
          const textHeight = font.heightAtSize(pdfSize);

          const pdfX = m.x * pageSize.width;
          // For text, CSS top is ~ cap height top. PDF y is baseline.
          // Adjusting by textHeight roughly aligns them.
          const pdfY = pageSize.height - (m.y * pageSize.height) - textHeight;

          const { r, g, b } = hexToRgb(m.color || '#000000');
          page.drawText(m.text, {
            x: pdfX,
            y: pdfY,
            size: pdfSize,
            font,
            color: PDFLib.rgb(r / 255, g / 255, b / 255)
          });
        }
      }

      const out = await pdfDoc.save({ useObjectStreams: false }); // better compatibility
      const blob = new Blob([out], { type: 'application/pdf' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'edited.pdf';
      a.click();
    });
  </script>
</body>

</html>