<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <link rel="icon" type="image/x-icon" href="pedefeul_logo.png">
  <title>Editor pdf gratis - pedefeul.ro</title>
  <!-- Manually bump css version before each commit/deploy -->
  <link rel="stylesheet" href="style.css?v=1.1.0">
  <!-- pdf.js (viewer/renderer) -->
  <script src="https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.min.js"></script>
  <!-- pdf-lib (writer) -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>

<body>
  <header class="app-header">
    <div class="header-top">
      <img src="pedefeul_logo.png" alt="Pedefeul logo" class="logo">
      <div class="titles">
        <div id="eyebrow"> PEDEFEUL.ro </div>
        <div class="control-bar">
          <label>Text: <input id="text" type="text" placeholder="..."></label>
          <label>Mărime: <input id="size" type="number" value="14" min="6" max="72"></label>
          <label>Culoare: <input id="color" type="color"></label>
          <label>Font:
            <select id="font">
              <option value="helvetica">Helvetica</option>
              <option value="times">Times</option>
              <option value="courier">Courier</option>
            </select>
          </label>
          <button id="place" disabled>Plasează</button>
          <button id="save" disabled>Salvează</button>
          <button id="reset" disabled>Resetează</button>
        </div>
      </div>
    </div>

  </header>

  <main class="app-body">
    <section class="upload-section">
      <h1>Editor gratis de fișiere .pdf</h1>
      <p class="upload-instructions">Încarcă fișierul tău pentru a putea adăuga text.</p>
      <label class="upload-button" for="file">Încarcă fișier</label>
      <input id="file" type="file" accept="application/pdf">
    </section>

    <div id="pages"></div>
  </main>

  <!-- MUST be type="module" to use JS imports -->
  <script type="module">
    import * as pdfjsLib from "https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.mjs";

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.worker.mjs";

    // Make globally accessible if needed
    window.pdfjsLib = pdfjsLib;

    let originalU8 = null;
    let originalBytes = null;          // ArrayBuffer of the uploaded PDF
    let docMeta = [];                  // per-page: {scale, width, height}
    let marks = [];                    // per-page array of placed text marks
    let selectedMark = null;           // { el, data, pageIndex }
    let markIdCounter = 0;
    let pendingPlacement = null;       // { text, size, font, color }
    const fileInput = document.getElementById('file');
    const textInput = document.getElementById('text');
    const sizeInput = document.getElementById('size');
    const colorInput = document.getElementById('color');
    const fontSelect = document.getElementById('font');
    const placeBtn = document.getElementById('place');
    const pagesEl = document.getElementById('pages');
    const saveBtn = document.getElementById('save');
    const uploadSection = document.querySelector('.upload-section');
    const resetBtn = document.getElementById('reset');

    const fontMap = {
      helvetica: {
        pdf: () => PDFLib.StandardFonts.Helvetica,
        css: 'Helvetica, Arial, sans-serif'
      },
      times: {
        pdf: () => PDFLib.StandardFonts.TimesRoman,
        css: '\'Times New Roman\', Times, serif'
      },
      courier: {
        pdf: () => PDFLib.StandardFonts.Courier,
        css: '\'Courier New\', Courier, monospace'
      }
    };

    function updatePlaceButtonState() {
      const hasText = !!textInput.value.trim();
      const hasPdf = !!originalBytes;
      placeBtn.disabled = !hasPdf || !hasText || !!pendingPlacement;
    }

    function clearSelection() {
      if (!selectedMark) return;
      selectedMark.el.classList.remove('selected');
      selectedMark = null;
    }

    function setSelectedMarkSize(sizeValue) {
      if (!selectedMark) return;
      const numeric = Number(sizeValue);
      if (!Number.isFinite(numeric)) return;
      const min = Number(sizeInput.min) || 0;
      const max = Number(sizeInput.max) || numeric;
      const clamped = Math.min(Math.max(numeric, min), max);
      selectedMark.data.size = clamped;
      selectedMark.el.style.fontSize = `${clamped}px`;
      sizeInput.value = clamped;
    }

    function setSelectedMarkFont(fontKey) {
      if (!selectedMark) return;
      const key = fontMap[fontKey] ? fontKey : 'helvetica';
      selectedMark.data.font = key;
      selectedMark.el.style.fontFamily = fontMap[key].css;
      fontSelect.value = key;
    }

    function setSelectedMarkColor(colorValue) {
      if (!selectedMark) return;
      const fallback = '#000000';
      const val = typeof colorValue === 'string' && colorValue.trim() ? colorValue : fallback;
      selectedMark.data.color = val;
      selectedMark.el.style.color = val;
      colorInput.value = val;
    }

    function selectMark(markEl, markData, pageIndex) {
      if (selectedMark && selectedMark.el === markEl) return;
      clearSelection();
      selectedMark = { el: markEl, data: markData, pageIndex };
      markEl.classList.add('selected');
      sizeInput.value = markData.size;
      fontSelect.value = fontMap[markData.font] ? markData.font : 'helvetica';
      colorInput.value = markData.color || '#000000';
    }

    function deleteMark(pageIndex, markData, markEl) {
      marks[pageIndex] = marks[pageIndex].filter(m => m !== markData);
      if (markEl.parentNode) {
        markEl.parentNode.removeChild(markEl);
      }
      if (selectedMark && selectedMark.el === markEl) {
        selectedMark = null;
      }
      const hasMarks = marks.some(arr => arr.length > 0);
      saveBtn.disabled = !hasMarks;
    }

    function editMarkText(markEl, markData) {
      const textSpan = markEl.querySelector('.mark-text');
      if (!textSpan || markEl.classList.contains('editing')) return;

      const previousText = markData.text;
      markEl.classList.add('editing');
      textSpan.contentEditable = 'true';
      textSpan.focus();

      // Select all text for quick editing
      const range = document.createRange();
      range.selectNodeContents(textSpan);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);

      function finish(save) {
        textSpan.contentEditable = 'false';
        markEl.classList.remove('editing');
        textSpan.removeEventListener('blur', onBlur);
        textSpan.removeEventListener('keydown', onKey);
        if (save) {
          markData.text = textSpan.textContent;
        } else {
          textSpan.textContent = previousText;
        }
      }

      function onBlur() {
        finish(true);
      }

      function onKey(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          textSpan.blur();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          finish(false);
          textSpan.blur();
        }
      }

      textSpan.addEventListener('blur', onBlur);
      textSpan.addEventListener('keydown', onKey);
    }

    function attachMarkDragging(markEl, markData, overlay, pageIndex) {
      function onMouseDown(e) {
        if (markEl.classList.contains('editing')) return;
        e.preventDefault();
        e.stopPropagation();
        const rect = overlay.getBoundingClientRect();
        const offsetX = (e.clientX - rect.left) - markData.x;
        const offsetY = (e.clientY - rect.top) - markData.y;

        function onMouseMove(moveEv) {
          const newX = moveEv.clientX - rect.left - offsetX;
          const newY = moveEv.clientY - rect.top - offsetY;
          markData.x = newX;
          markData.y = newY;
          markEl.style.left = `${newX}px`;
          markEl.style.top = `${newY}px`;
        }

        function onMouseUp(upEv) {
          upEv.stopPropagation();
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      }

      markEl.addEventListener('mousedown', onMouseDown);
      markEl.addEventListener('click', (ev) => {
        ev.stopPropagation();
        selectMark(markEl, markData, pageIndex);
      });
      markEl.addEventListener('dblclick', (ev) => {
        ev.stopPropagation();
        selectMark(markEl, markData, pageIndex);
        editMarkText(markEl, markData);
      });
    }

    function placeMark(pageIndex, overlay, wrapper, x, y, text, size, fontKey, color) {
      const fontInfo = fontMap[fontKey] || fontMap.helvetica;
      const markData = { id: markIdCounter++, x, y, text, size, font: fontKey, color };
      marks[pageIndex].push(markData);

      const m = document.createElement('div');
      m.className = 'mark';
      m.style.fontSize = size + 'px';
      m.style.left = x + 'px';
      m.style.top = y + 'px';
      m.style.color = color;
      m.style.fontFamily = fontInfo.css;

      const textSpan = document.createElement('span');
      textSpan.className = 'mark-text';
      textSpan.textContent = text;
      m.appendChild(textSpan);

      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.className = 'delete-btn';
      delBtn.textContent = 'x';
      delBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        deleteMark(pageIndex, markData, m);
      });

      attachMarkDragging(m, markData, overlay, pageIndex);
      m.appendChild(delBtn);
      overlay.appendChild(m);
      saveBtn.disabled = false;
      selectMark(m, markData, pageIndex);
    }

    placeBtn.addEventListener('click', () => {
      const text = textInput.value.trim();
      if (!text) return;
      const size = +sizeInput.value || 14;
      const font = fontSelect.value;
      const color = colorInput.value || '#000000';
      pendingPlacement = { text, size, font, color };
      updatePlaceButtonState();
    });

    textInput.addEventListener('input', updatePlaceButtonState);
    sizeInput.addEventListener('input', () => {
      if (!selectedMark) return;
      setSelectedMarkSize(sizeInput.value);
    });
    fontSelect.addEventListener('change', () => {
      if (!selectedMark) return;
      setSelectedMarkFont(fontSelect.value);
    });
    colorInput.addEventListener('input', () => {
      if (!selectedMark) return;
      setSelectedMarkColor(colorInput.value);
    });
    updatePlaceButtonState();

    function enterEditMode() {
      uploadSection.classList.add('hidden');
      resetBtn.disabled = false;
    }

    function resetApp() {
      clearSelection();
      pagesEl.innerHTML = '';
      originalU8 = null;
      originalBytes = null;
      docMeta = [];
      marks = [];
      markIdCounter = 0;
      pendingPlacement = null;
      textInput.value = '';
      sizeInput.value = '14';
      fontSelect.value = 'helvetica';
      saveBtn.disabled = true;
      updatePlaceButtonState();
      fileInput.value = '';
      uploadSection.classList.remove('hidden');
      resetBtn.disabled = true;
    }

    // Render uploaded PDF
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const buf = await file.arrayBuffer();
      const u8 = new Uint8Array(buf);

      // Reset state for new document
      clearSelection();
      pendingPlacement = null;
      markIdCounter = 0;
      saveBtn.disabled = true;
      updatePlaceButtonState();

      // Keep a private copy for pdf-lib (never hand this to pdf.js)
      originalU8 = u8.slice();
      originalBytes = originalU8.buffer;
      updatePlaceButtonState();

      // Hand a separate clone to pdf.js (it can detach this one)
      const renderU8 = u8.slice();
      const pdf = await pdfjsLib.getDocument({ data: renderU8 }).promise;

      pagesEl.innerHTML = '';
      docMeta = []; marks = [];

      for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const scale = 1.25; // render scale (UI only)
        const viewport = page.getViewport({ scale });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');

        await page.render({ canvasContext: ctx, viewport }).promise;

        // container and overlay for marks
        const wrapper = document.createElement('div');
        wrapper.className = 'page';
        wrapper.appendChild(canvas);

        const overlay = document.createElement('div');
        overlay.className = 'overlay';
        overlay.style.width = canvas.width + 'px';
        overlay.style.height = canvas.height + 'px';
        wrapper.appendChild(overlay);

        // click to place text
        const pageIndex = p - 1;
        wrapper.addEventListener('click', (ev) => {
          if (!originalBytes) return;
          if (!pendingPlacement) return;
          if (ev.target.classList.contains('mark')) return;
          const r = overlay.getBoundingClientRect();
          const x = ev.clientX - r.left;
          const y = ev.clientY - r.top;

          const { text, size, font, color } = pendingPlacement;
          placeMark(pageIndex, overlay, wrapper, x, y, text, size, font, color);
          textInput.value = '';
          pendingPlacement = null;
          updatePlaceButtonState();
        });

        pagesEl.appendChild(wrapper);
        docMeta.push({ scale, width: viewport.width, height: viewport.height, pdfWidth: page.view[2], pdfHeight: page.view[3] });
        marks.push([]);
      }

      enterEditMode();
    });

    resetBtn.addEventListener('click', resetApp);

    // Save: write overlays into the PDF using pdf-lib
    saveBtn.addEventListener('click', async () => {
      if (!originalBytes) return;

      const pdfDoc = await PDFLib.PDFDocument.load(originalU8, { updateMetadata: false });
      const fontCache = {};

      function hexToRgb(hex) {
        if (typeof hex !== 'string') return { r: 0, g: 0, b: 0 };
        const cleaned = hex.replace('#', '').trim();
        if (cleaned.length === 3) {
          const r = parseInt(cleaned[0] + cleaned[0], 16);
          const g = parseInt(cleaned[1] + cleaned[1], 16);
          const b = parseInt(cleaned[2] + cleaned[2], 16);
          return { r, g, b };
        }
        if (cleaned.length === 6) {
          const r = parseInt(cleaned.slice(0, 2), 16);
          const g = parseInt(cleaned.slice(2, 4), 16);
          const b = parseInt(cleaned.slice(4, 6), 16);
          if ([r, g, b].some(v => Number.isNaN(v))) return { r: 0, g: 0, b: 0 };
          return { r, g, b };
        }
        return { r: 0, g: 0, b: 0 };
      }

      async function getEmbeddedFont(key) {
        const fontKey = key && fontMap[key] ? key : 'helvetica';
        if (fontCache[fontKey]) return fontCache[fontKey];
        const fontName = fontMap[fontKey].pdf();
        const embedded = await pdfDoc.embedFont(fontName);
        fontCache[fontKey] = embedded;
        return embedded;
      }

      for (let i = 0; i < pdfDoc.getPageCount(); i++) {
        const page = pdfDoc.getPage(i);
        const pageSize = page.getSize(); // { width, height } in PDF points
        const { scale, height } = docMeta[i];

        // Convert screen (canvas) coords to PDF user space:
        // pdfX = screenX / scale
        // pdfY = pageHeight - (screenY / scale)
        for (const m of marks[i]) {
          const pdfSize = m.size / scale;
          const pdfX = m.x / scale;
          const font = await getEmbeddedFont(m.font);
          const textHeight = font.heightAtSize(pdfSize);
          // Position baseline so the rendered text sits inside the mark box (CSS uses top-left)
          const pdfY = pageSize.height - (m.y / scale) - textHeight;
          const { r, g, b } = hexToRgb(m.color || '#000000');
          page.drawText(m.text, {
            x: pdfX,
            y: pdfY,
            size: pdfSize,
            font,
            color: PDFLib.rgb(r / 255, g / 255, b / 255)
          });
        }
      }

      const out = await pdfDoc.save({ useObjectStreams: false }); // better compatibility
      const blob = new Blob([out], { type: 'application/pdf' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'edited.pdf';
      a.click();
    });
  </script>
</body>

</html>
